### All Possible Ways to Activate Model Validation in Ruby on Rails with Examples

Model validations in Ruby on Rails are primarily handled through **ActiveModel::Validations** in Active Record models. They ensure data integrity before saving to the database. The official guide is at: https://guides.rubyonrails.org/active_record_validations.html.

#### 1. Built-in Validation Helpers
Rails provides many helper methods via `validates`. These are the most common ways.

| Validator                  | Description                                                                 | Example Code                                                                 |
|----------------------------|-----------------------------------------------------------------------------|------------------------------------------------------------------------------|
| `presence`                 | Ensures value is not nil or blank.                                          | `validates :name, presence: true`                                            |
| `absence`                  | Ensures value is blank.                                                     | `validates :legacy_code, absence: true`                                      |
| `acceptance`               | For boolean fields (e.g., terms acceptance).                                | `validates :terms, acceptance: true`                                         |
| `confirmation`             | Requires a matching confirmation field (e.g., password_confirmation).      | `validates :password, confirmation: true`                                    |
| `exclusion`                | Ensures value not in a set.                                                 | `validates :subdomain, exclusion: { in: %w[www admin] }`                     |
| `format`                   | Matches regex.                                                              | `validates :email, format: { with: URI::MailTo::EMAIL_REGEXP }`              |
| `inclusion`                | Ensures value in a set.                                                     | `validates :gender, inclusion: { in: %w[male female other] }`                |
| `length`                   | Checks string/array length.                                                 | `validates :bio, length: { maximum: 500 }`                                   |
| `numericality`             | Ensures numeric (with options like greater_than, only_integer).             | `validates :age, numericality: { greater_than_or_equal_to: 18 }`             |
| `uniqueness`               | Ensures unique in database (race-condition aware with indexes).             | `validates :email, uniqueness: { case_sensitive: false }`                   |
| `associated`               | Ensures associated objects are valid.                                       | `validates :books, associated: true` (in Author model)                       |
| `comparison` (Rails 7+)    | Compares values (e.g., greater_than another attribute).                     | `validates :end_date, comparison: { greater_than: :start_date }`             |

Multiple in one call:
```ruby
validates :title, presence: true, length: { minimum: 5 }
```

#### 2. Common Options for All Validators
- `:message` — Custom error message.
- `:on` — Context: `:create`, `:update`, or array.
- `:if` / `:unless` — Conditional (symbol, proc, or lambda).
- `:allow_nil` — Skip if nil.
- `:allow_blank` — Skip if blank? (nil or empty string).
- `:strict` — Raise exception on failure (Rails 4+).

Example:
```ruby
validates :email, presence: true, uniqueness: true, 
          if: :active?, allow_nil: true, message: "must be valid!"
```

Conditional example:
```ruby
validates :card_number, presence: true, if: :paid_with_card?

def paid_with_card?
  payment_type == "card"
end
```

#### 3. Custom Methods
Add a method and call `validate :method_name`.

Example:
```ruby
class Article < ApplicationRecord
  validate :publication_date_cannot_be_future

  def publication_date_cannot_be_future
    if publication_date.present? && publication_date > Date.today
      errors.add(:publication_date, "can't be in the future")
    end
  end
end
```

#### 4. Custom Validators
Create a class inheriting from `ActiveModel::Validator` or `ActiveModel::EachValidator`.

- Full record validator:
```ruby
class MyValidator < ActiveModel::Validator
  def validate(record)
    if some_complex_condition(record)
      record.errors.add :base, "Complex error"
    end
  end
end

class Person < ApplicationRecord
  validates_with MyValidator
end
```

- Per-attribute (EachValidator):
```ruby
class EmailValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless value =~ /\A[^@\s]+@[^@\s]+\z/
      record.errors.add attribute, "is not an email"
    end
  end
end

class Person < ApplicationRecord
  validates :email, email: true  # Uses EmailValidator
end
```

#### 5. Triggering Validations
- `valid?` or `invalid?` — Runs validations, returns true/false.
- `validate!` — Runs and raises `ActiveRecord::RecordInvalid` if invalid.
- Automatically on `save`, `create`, `update` (unless `save(validate: false)`).
- Manual context: `valid?(:create)`

Errors access: `model.errors.full_messages`

For a complete, up-to-date list and details, refer to the official Rails Guide linked above.

**Note:** I cannot directly generate or provide a downloadable PDF file here. You can copy this content into a tool like Markdown to PDF converter (e.g., online tools or pandoc), or print this page as PDF from your browser. Alternatively, the official Rails Guide can be viewed and printed/saved as PDF via browser options.




# Custom Validators in Ruby on Rails

Custom validators in Ruby on Rails extend the built-in validation system provided by Active Record, allowing you to implement complex or domain-specific validation logic that isn't covered by standard helpers like `presence`, `uniqueness`, or `numericality`. They ensure data integrity by checking conditions before saving records to the database.

Custom validators can be simple methods or full classes, and they integrate seamlessly with Rails' validation lifecycle (e.g., triggered by `valid?`, `save`, or custom contexts).

Rails validations, including custom ones, add errors to the model's `errors` collection when they fail. You can inspect these errors via methods like `errors[:attribute]`, `errors.full_messages`, or `errors.where(:attribute, :type)`. Custom validators support common options like `:on` (e.g., `:create` or `:update`), `:if`/`:unless` for conditionals, `:strict` to raise exceptions, and `:message` for custom error text.

Below is an in-depth explanation of the main approaches to custom validators, including when to use them, implementation details, error handling, best practices, and notes on recent Rails versions (up to Rails 8 as of late 2025).

## 1. Custom Validation Methods

This is the simplest way to add custom logic. You define an instance method in your model that performs the validation and adds errors if needed. Then, register it with the `validate` class method (singular, not `validates`).

### When to Use
- For model-specific, one-off validations that don't need to be reused across models.
- When the logic is straightforward and tied to a single model.
- Avoid if the validation is complex or reusable—use validator classes instead.

### Implementation
The method should check conditions and use `errors.add(:attribute, "message")` or `errors.add(:base, "message")` for record-level errors. It runs in the context of the model instance, so you have access to all attributes and methods.

#### Example: Invoice expiration and discount rules
```ruby
class Invoice < ApplicationRecord
  validate :expiration_date_cannot_be_in_the_past
  validate :discount_cannot_be_greater_than_total_value

  def expiration_date_cannot_be_in_the_past
    if expiration_date.present? && expiration_date < Date.today
      errors.add(:expiration_date, "can't be in the past")
    end
  end

  def discount_cannot_be_greater_than_total_value
    if discount > total_value
      errors.add(:discount, "can't be greater than total value")
    end
  end
end


# Rails Custom Validations Guide

## Validation Flow

If `invoice.valid?` fails, the `errors` object will be populated accordingly.

---

## Options and Conditionals

* Use `:on` to run validations only on specific actions or contexts.
* Use `:if` or `:unless` to dynamically enable or disable validations.

### Example with Context

```ruby
class Invoice < ApplicationRecord
  validate :active_customer, on: :create

  def active_customer
    errors.add(:customer_id, "is not active") unless customer.active?
  end
end
```

---

## Error Handling

* Use `errors.add` for attribute-specific issues.
* For whole-record errors (not tied to one field), use `:base`.
* Error messages can include placeholders like `%{value}` for invalid values.

---

## Custom Validator Classes

For more structured and reusable validations, create validator classes that inherit from:

* `ActiveModel::Validator` (whole-record validation)
* `ActiveModel::EachValidator` (attribute-specific validation)

These classes are typically placed in `app/validators/`.

### When to Use

* Validation logic must be reused across models or attributes
* Rules are complex or involve multiple fields
* External dependencies are involved
* You want DRY, testable validation logic

---

## 2.1 Whole Record Validators (`ActiveModel::Validator`)

Validates the entire model instance using `validates_with`. The `validate(record)` method receives the model instance.

### Example: Address Validation

```ruby
# app/validators/address_validator.rb
class AddressValidator < ActiveModel::Validator
  def validate(record)
    record.errors.add(:house_number, "is required") if record.house_number.blank?
    record.errors.add(:street, "is required") if record.street.blank?
    record.errors.add(:postcode, "is required") if record.postcode.blank?
  end
end
```

```ruby
# app/models/invoice.rb
class Invoice < ApplicationRecord
  validates_with AddressValidator
end
```

### With Custom Options

```ruby
class AddressValidator < ActiveModel::Validator
  def validate(record)
    options[:fields].each do |field|
      if record.send(field).blank?
        record.errors.add(field, "is required")
      end
    end
  end
end

class Invoice < ApplicationRecord
  validates_with AddressValidator, fields: [:house_number, :street, :postcode, :country]
end
```

---

## 2.2 Attribute-Specific Validators (`ActiveModel::EachValidator`)

Validates one attribute at a time. Use with:

```ruby
validates :attribute, your_validator: true
```

The `validate_each(record, attribute, value)` method receives the record, attribute name, and value.

### Example: Custom Email Validator

```ruby
# app/validators/email_validator.rb
class EmailValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless URI::MailTo::EMAIL_REGEXP.match?(value)
      record.errors.add(attribute, options[:message] || "is not an email")
    end
  end
end
```

```ruby
# app/models/person.rb
class Person < ApplicationRecord
  validates :email, presence: true, email: true
end
```

#### Reuse with Options

```ruby
validates :secondary_email, email: { message: "must be valid" }
```

---

## Error Handling in Validator Classes

* Use `record.errors.add`
* Attribute validators must always add errors to the provided attribute
* Support custom messages via `options[:message]`
* Use I18n for localization

```ruby
record.errors.add(attribute, :invalid, message: "custom %{value}")
```

---

## Best Practices

* **Organization**: Place validators in `app/validators/` and rely on Rails autoloading
* **Reusability**: Prefer validator classes for shared logic
* **Performance**: Avoid heavy operations (e.g., database queries)
* **Testing**: Unit-test validators independently and integration-test models
* **Contexts**: Use custom contexts for multi-step forms
* **Strict Mode**: Use `strict: true` to raise `ActiveRecord::RecordInvalid`

---

## Updates in Recent Rails Versions (Rails 7 & 8)

* Enhanced error objects (`errors.where(:attribute, :too_short)`)
* Improved multi-context validation support
* Optimized association validations
* Expanded strict validation behavior
* No major breaking changes

---

## Custom Validation Contexts Example

```ruby
class User < ApplicationRecord
  validate :personal_information, on: :personal_info
  validate :contact_information, on: :contact_info

  def personal_information
    errors.add(:base, "Name must be present") if first_name.blank?
    errors.add(:base, "Age must be at least 18") if age && age < 18
  end

  def contact_information
    errors.add(:base, "Email must be present") if email.blank?
    errors.add(:base, "Phone number must be present") if phone.blank?
  end
end
```

Trigger a specific context:

```ruby
user.valid?(:personal_info)
```

---

## Complete Examples

### Product Code Validator (Attribute-Specific)

```ruby
# app/validators/product_code_validator.rb
class ProductCodeValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    return if value.blank?

    unless value.match?(/\A[A-Z]{2}\d{4}\z/)
      record.errors.add(attribute, "must be in format XX1234")
    end
  end
end
```

```ruby
# app/models/product.rb
class Product < ApplicationRecord
  validates :code, presence: true, product_code: true
end
```

---

### Complete Profile Validator (Whole Record)

```ruby
# app/validators/complete_profile_validator.rb
class CompleteProfileValidator < ActiveModel::Validator
  def validate(record)
    unless record.name && record.email && record.phone
      record.errors.add(:base, "All contact information must be provided")
    end
  end
end
```

```ruby
# app/models/user.rb
class User < ApplicationRecord
  validates_with CompleteProfileValidator, on: :profile_completion
end
```

---

Custom validators provide flexibility for enforcing business rules while keeping Rails applications maintainable, testable, and scalable.
